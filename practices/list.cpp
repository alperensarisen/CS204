#include <iostream>
using namespace std;

//TODO: Add2End, printList, addInOrder, deleteNode, CountnodeCircular, isCircular, search
//*        +         -          +           +               +               +       
struct node{
    int val;
    node *next;
    node():val(0),next(nullptr){}
    node(int v, node* n):val(v),next(n){}
};
node *Add2End(node* head, int v){
    if(!head) return new node(v,nullptr);
    node* p = head;
    while(p->next){p = p->next;}
    p->next = new node(v,nullptr);
    return head;
}
void addEnd(node* &head, int v){
    if(!head){head = new node(v,nullptr); return;}
    node *p = head;
    while(p->next){p = p->next;}
    p->next = new node(v,nullptr);
}
node* addInOrder(node* head, int v){
    if(!head){return new node(v,nullptr);}
    if(head->val > v) return new node(v,head);

    node* p = head;
    while(p->next && p->next->val<v){
        p = p->next;
    }
    p->next = new node(v,p->next);
    return head;
}
void addOrder(node* &head, int v){
    if(!head){head = new node(v,nullptr); return;}
    if(head->val > v){
        node *nh = new node(v,head);
        head = nh;
        return;
    }
    node *temp = head;
    while(temp->next && temp->next->val<v){
        temp = temp->next;
    }
    temp->next = new node(v,temp->next);

}
node* deleteNode(node* head,int v){
    if(!head) return nullptr;
    if(head->val == v){
        node* oh = head;
        head = head->next;
        delete oh;
        return head;
    }
    node *temp = head;
    while(temp->next && temp->next->val != v){temp = temp->next;}
    if(!temp->next) return head;
    node *del = temp->next;
    temp->next = temp->next->next;
    delete del;
    return head;
}
void deleteN(node* &head, int v){
    if(!head){return;}
    if(head->val == v){
        node *d = head;
        head = head->next;
        delete d;
        return;
    }
    node *temp = head;
    while(temp->next && temp->next->val != v){temp = temp->next;}
    if(temp->next == nullptr){return;}
    node* dlt = temp->next;
    temp->next = temp->next->next;
    delete dlt;
}
int countCircular(node *head){
    if(!head) return 0;
    node* temp = head->next;
    int count = 1; //head inclueded.
    while(temp != head){
        count++;
        temp = temp->next;
    }
    return count;
}
//! Floyd’s Cycle Detection (Tortoise & Hare) algorithm 
bool isCircular(node *head){
    if(!head) return false;
    node *slow = head;
    node *fast = head;
    while(fast && fast->next){
        slow = slow->next;
        fast = fast->next->next;
        if(slow == fast) return true;
    }
    return false;
}
template<class itemType>
node* search(node* head, itemType val){
    if(!head) return nullptr;
    node* temp = head;
    while(temp){
        if(val == temp->val) return temp;
        temp = temp->next;
    }
    return nullptr;
}
node* searchRec(node* head, int v){
    if(!head) return nullptr;
    if(head->val == v) return head;
    return searchRec(head->next, v);
}
void printList(node * head){
    node *temp = head;
    while(temp){
        cout<<temp->val<<" ";
        temp = temp->next;
    }
    cout<<"\n";
}
//Test part generated by AI.
int main(){
    // === Test 1: Add2End & addEnd ===
    node* head = nullptr;

    head = Add2End(head, 3);
    head = Add2End(head, 7);
    head = Add2End(head, 10);

    cout << "List after Add2End: ";
    printList(head);

    addEnd(head, 15);
    addEnd(head, 1);

    cout << "List after addEnd: ";
    printList(head);


    // === Test 2: addInOrder & addOrder ===
    node* sorted = nullptr;

    sorted = addInOrder(sorted, 5);
    sorted = addInOrder(sorted, 2);
    sorted = addInOrder(sorted, 8);
    sorted = addInOrder(sorted, 1);

    cout << "List after addInOrder: ";
    printList(sorted);

    addOrder(sorted, 4);
    addOrder(sorted, 0);

    cout << "List after addOrder: ";
    printList(sorted);


    // === Test 3: deleteNode & deleteN ===
    sorted = deleteNode(sorted, 4); // remove 4
    cout << "After deleteNode(4): ";
    printList(sorted);

    deleteN(sorted, 0); // remove 0
    cout << "After deleteN(0): ";
    printList(sorted);


    // === Test 4: search & searchRec ===
    node* f1 = search(sorted, 5);
    cout << "search(sorted, 5): ";
    if(f1) cout << "found (" << f1->val << ")\n";
    else   cout << "not found\n";

    node* f2 = searchRec(sorted, 100);
    cout << "searchRec(sorted, 100): ";
    if(f2) cout << "found\n";
    else   cout << "not found\n";


    // === Test 5: Circular list & isCircular & countCircular ===
    node* circ = nullptr;

    circ = Add2End(circ, 1);
    circ = Add2End(circ, 2);
    circ = Add2End(circ, 3);

    // make the list circular (last->next = head)
    node* p = circ;
    while(p->next) p = p->next;
    p->next = circ;

    cout << "isCircular(circ): " 
         << (isCircular(circ) ? "true" : "false") << endl;

    cout << "countCircular(circ): " << countCircular(circ) << endl;

    // Do NOT call printList(circ) → infinite loop!

    return 0;
}
